// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by tool/renderer/generate.js

// ignore_for_file: constant_identifier_names

// dart format off

class RawShaders {
static const String texture_frag = '''
#version 460 core

uniform TextureUbo {
  float opacity;
} texture_ubo;

uniform sampler2D u_texture;

in vec2 v_texCoord;

out vec4 f_color;

void main() {
  vec4 color = texture(u_texture, v_texCoord) * texture_ubo.opacity;
  if (color.a < 0.01) discard;

  f_color = color;
}
''';

static const String texture_vert = '''
#version 460 core

in vec2 position;
in vec2 texCoord;

out vec2 v_texCoord;

void main() {
  gl_Position = vec4(position, 0.0, 1.0);
  v_texCoord = texCoord;
}
''';

static const String background_frag = '''
#version 460 core

precision highp float;

#define prop_crossfade(a, b) mix(a, b, tile_info.zoom - floor(tile_info.zoom))

#define prop_step(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, step(end_stop, tile_info.zoom))

#define prop_interpolate(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(1.0, start_stop, end_stop, tile_info.zoom))

#define prop_interpolate_exponential(base, start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(base, start_stop, end_stop, tile_info.zoom))

float prop_interpolate_factor(
  float base,
  float start_stop,
  float end_stop,
  float t
) {
  float difference = end_stop - start_stop;
  float progress = t - start_stop;

  if (difference == 0.0) return 0.0;
  else if (base == 1.0) return progress / difference;
  else return (pow(base, progress) - 1.0) / (pow(base, difference) - 1.0);
}


#pragma prop: declare(highp vec4 color)
#pragma prop: declare(highp float opacity)

in vec3 v_world_position;

out highp vec4 f_color;

void main() {
  #pragma prop: resolve
  f_color = color * opacity;
}

''';

static const String background_vert = '''
#version 460 core

precision highp float;

layout (std140) uniform TileInfo {
  // transforms and camera
  mat4 mvp;
  mat4 camera_transform;
  mat4 model_transform;
  vec3 camera_position;

  // light
  vec3 light_direction;
  float light_intensity;
  vec4 light_color;

  // other data
  float units_per_pixel;
  float zoom;
} tile_info;

#define prop_crossfade(a, b) mix(a, b, tile_info.zoom - floor(tile_info.zoom))

#define prop_step(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, step(end_stop, tile_info.zoom))

#define prop_interpolate(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(1.0, start_stop, end_stop, tile_info.zoom))

#define prop_interpolate_exponential(base, start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(base, start_stop, end_stop, tile_info.zoom))

float prop_interpolate_factor(
  float base,
  float start_stop,
  float end_stop,
  float t
) {
  float difference = end_stop - start_stop;
  float progress = t - start_stop;

  if (difference == 0.0) return 0.0;
  else if (base == 1.0) return progress / difference;
  else return (pow(base, progress) - 1.0) / (pow(base, difference) - 1.0);
}


in highp vec2 position;

#pragma prop: declare(highp vec4 color)
#pragma prop: declare(highp float opacity)

out vec3 v_world_position;

void main() {
  #pragma prop: resolve(...)
  vec4 world_position = tile_info.model_transform * vec4(position, 0.0, 1.0);
  v_world_position = world_position.xyz;
  gl_Position = tile_info.mvp * vec4(position, 0.0, 1.0);
}

''';

static const String fill_frag = '''
#version 460 core

precision highp float;

#define prop_crossfade(a, b) mix(a, b, tile_info.zoom - floor(tile_info.zoom))

#define prop_step(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, step(end_stop, tile_info.zoom))

#define prop_interpolate(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(1.0, start_stop, end_stop, tile_info.zoom))

#define prop_interpolate_exponential(base, start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(base, start_stop, end_stop, tile_info.zoom))

float prop_interpolate_factor(
  float base,
  float start_stop,
  float end_stop,
  float t
) {
  float difference = end_stop - start_stop;
  float progress = t - start_stop;

  if (difference == 0.0) return 0.0;
  else if (base == 1.0) return progress / difference;
  else return (pow(base, progress) - 1.0) / (pow(base, difference) - 1.0);
}


#pragma prop: declare(bool antialias)
#pragma prop: declare(highp float opacity)
#pragma prop: declare(highp vec4 color)
#pragma prop: declare(highp vec2 translate)

in vec3 v_world_position;

out highp vec4 f_color;

void main() {
  #pragma prop: resolve
  f_color = color * opacity;
}

''';

static const String fill_vert = '''
#version 460 core

precision highp float;

layout (std140) uniform TileInfo {
  // transforms and camera
  mat4 mvp;
  mat4 camera_transform;
  mat4 model_transform;
  vec3 camera_position;

  // light
  vec3 light_direction;
  float light_intensity;
  vec4 light_color;

  // other data
  float units_per_pixel;
  float zoom;
} tile_info;

#define prop_crossfade(a, b) mix(a, b, tile_info.zoom - floor(tile_info.zoom))

#define prop_step(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, step(end_stop, tile_info.zoom))

#define prop_interpolate(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(1.0, start_stop, end_stop, tile_info.zoom))

#define prop_interpolate_exponential(base, start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(base, start_stop, end_stop, tile_info.zoom))

float prop_interpolate_factor(
  float base,
  float start_stop,
  float end_stop,
  float t
) {
  float difference = end_stop - start_stop;
  float progress = t - start_stop;

  if (difference == 0.0) return 0.0;
  else if (base == 1.0) return progress / difference;
  else return (pow(base, progress) - 1.0) / (pow(base, difference) - 1.0);
}


in highp vec2 position;

#pragma prop: declare(bool antialias)
#pragma prop: declare(highp float opacity)
#pragma prop: declare(highp vec4 color)
#pragma prop: declare(highp vec2 translate)

out vec3 v_world_position;

void main() {
  #pragma prop: resolve
  vec2 translated = position + translate;
  vec4 world_position = tile_info.model_transform * vec4(translated, 0.0, 1.0);

  v_world_position = world_position.xyz;
  gl_Position = tile_info.mvp * vec4(translated, 0.0, 1.0);
}

''';

static const String fill_extrusion_frag = '''
#version 460 core

precision highp float;

layout (std140) uniform TileInfo {
  // transforms and camera
  mat4 mvp;
  mat4 camera_transform;
  mat4 model_transform;
  vec3 camera_position;

  // light
  vec3 light_direction;
  float light_intensity;
  vec4 light_color;

  // other data
  float units_per_pixel;
  float zoom;
} tile_info;

#define prop_crossfade(a, b) mix(a, b, tile_info.zoom - floor(tile_info.zoom))

#define prop_step(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, step(end_stop, tile_info.zoom))

#define prop_interpolate(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(1.0, start_stop, end_stop, tile_info.zoom))

#define prop_interpolate_exponential(base, start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(base, start_stop, end_stop, tile_info.zoom))

float prop_interpolate_factor(
  float base,
  float start_stop,
  float end_stop,
  float t
) {
  float difference = end_stop - start_stop;
  float progress = t - start_stop;

  if (difference == 0.0) return 0.0;
  else if (base == 1.0) return progress / difference;
  else return (pow(base, progress) - 1.0) / (pow(base, difference) - 1.0);
}


#pragma prop: declare(highp vec4 color)
#pragma prop: declare(highp vec2 translate)
#pragma prop: declare(highp float height)
#pragma prop: declare(highp float base)

in vec3 v_position;
in vec3 v_normal;

out highp vec4 f_color;

void main() {
  #pragma prop: resolve(...)

  // Lights
  vec3 light_color = tile_info.light_color.rgb;
  float light_intensity = tile_info.light_intensity;

  // Ambient occlussion based on the distance from ground
  float ao_intensity = clamp((24.0 - v_position.z) / 24.0, 0.0, 1.0) * 0.125;

  // No AO on the floors/roofs
  ao_intensity *= 1.0 - abs(v_normal.z);
  vec3 ao = vec3(ao_intensity);

  float diffuse_amount = max(dot(v_normal, tile_info.light_direction), 0.0);
  vec3 ambient = light_color * light_intensity * 1.0;
  vec3 diffuse = light_color * light_intensity * diffuse_amount;
  vec4 light = vec4(ambient + diffuse - ao, 1.0);

  vec4 result_color = color * light;
  f_color = result_color;
}

''';

static const String fill_extrusion_vert = '''
#version 460 core

precision highp float;

layout (std140) uniform TileInfo {
  // transforms and camera
  mat4 mvp;
  mat4 camera_transform;
  mat4 model_transform;
  vec3 camera_position;

  // light
  vec3 light_direction;
  float light_intensity;
  vec4 light_color;

  // other data
  float units_per_pixel;
  float zoom;
} tile_info;

#define prop_crossfade(a, b) mix(a, b, tile_info.zoom - floor(tile_info.zoom))

#define prop_step(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, step(end_stop, tile_info.zoom))

#define prop_interpolate(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(1.0, start_stop, end_stop, tile_info.zoom))

#define prop_interpolate_exponential(base, start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(base, start_stop, end_stop, tile_info.zoom))

float prop_interpolate_factor(
  float base,
  float start_stop,
  float end_stop,
  float t
) {
  float difference = end_stop - start_stop;
  float progress = t - start_stop;

  if (difference == 0.0) return 0.0;
  else if (base == 1.0) return progress / difference;
  else return (pow(base, progress) - 1.0) / (pow(base, difference) - 1.0);
}


in highp vec3 position;
in highp vec3 normal;

#pragma prop: declare(highp vec4 color)
#pragma prop: declare(highp vec2 translate)
#pragma prop: declare(highp float height)
#pragma prop: declare(highp float base)

out vec3 v_position;
out vec3 v_normal;

void main() {
  #pragma prop: resolve
  vec2 translated_pos = position.xy + translate;
  vec3 resolved_pos = vec3(translated_pos.xy, base) + vec3(0.0, 0.0, position.z * height);

  v_position = resolved_pos;
  v_normal = normal;
  gl_Position = tile_info.mvp * vec4(resolved_pos, 1.0);
}

''';

static const String line_frag = '''
#version 460 core

#define prop_crossfade(a, b) mix(a, b, tile_info.zoom - floor(tile_info.zoom))

#define prop_step(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, step(end_stop, tile_info.zoom))

#define prop_interpolate(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(1.0, start_stop, end_stop, tile_info.zoom))

#define prop_interpolate_exponential(base, start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(base, start_stop, end_stop, tile_info.zoom))

float prop_interpolate_factor(
  float base,
  float start_stop,
  float end_stop,
  float t
) {
  float difference = end_stop - start_stop;
  float progress = t - start_stop;

  if (difference == 0.0) return 0.0;
  else if (base == 1.0) return progress / difference;
  else return (pow(base, progress) - 1.0) / (pow(base, difference) - 1.0);
}


#pragma prop: declare(highp vec4 color)
#pragma prop: declare(float opacity)
#pragma prop: declare(float width)

out highp vec4 f_color;

void main() {
  #pragma prop: resolve
  f_color = color * opacity;
}

''';

static const String line_vert = '''
#version 460 core

layout (std140) uniform TileInfo {
  // transforms and camera
  mat4 mvp;
  mat4 camera_transform;
  mat4 model_transform;
  vec3 camera_position;

  // light
  vec3 light_direction;
  float light_intensity;
  vec4 light_color;

  // other data
  float units_per_pixel;
  float zoom;
} tile_info;

#define prop_crossfade(a, b) mix(a, b, tile_info.zoom - floor(tile_info.zoom))

#define prop_step(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, step(end_stop, tile_info.zoom))

#define prop_interpolate(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(1.0, start_stop, end_stop, tile_info.zoom))

#define prop_interpolate_exponential(base, start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(base, start_stop, end_stop, tile_info.zoom))

float prop_interpolate_factor(
  float base,
  float start_stop,
  float end_stop,
  float t
) {
  float difference = end_stop - start_stop;
  float progress = t - start_stop;

  if (difference == 0.0) return 0.0;
  else if (base == 1.0) return progress / difference;
  else return (pow(base, progress) - 1.0) / (pow(base, difference) - 1.0);
}


in highp vec2 position;
in highp vec2 normal;

#pragma prop: declare(highp vec4 color)
#pragma prop: declare(float opacity)
#pragma prop: declare(float width)

void main() {
  #pragma prop: resolve

  // Width is defined in terms of screen pixels, so we need to convert it.
  float local_width = width * tile_info.units_per_pixel;
  vec2 offset = normal * local_width * 0.5;
  vec2 resolved_pos = position + offset;

  gl_Position = tile_info.mvp * vec4(resolved_pos, 0.0, 1.0);
}

''';

}