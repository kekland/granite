// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by tool/renderer/generate.js

// ignore_for_file: constant_identifier_names

// dart format off

class RawShaders {
static const String background_frag = '''
#version 460 core

precision highp float;

uniform Tile {
  highp mat4 local_to_gl;
  highp float size;
  highp float extent;
  highp float opacity;
  highp float zoom;
} tile;

vec4 project_tile_position(vec2 position) {
  return vec4(position.x * tile.size, position.y * tile.size, 0.0, 1.0);
}

vec4 project_tile_position(vec3 position) {
  return vec4(position.x * tile.size, position.y * tile.size, position.z * tile.size, 1.0);
}

float project_pixel_length(float len) {
  return len * tile.size / tile.extent;
}

#define prop_crossfade(a, b) mix(a, b, tile.zoom - floor(tile.zoom))

#define prop_step(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, step(end_stop, tile.zoom))

#define prop_interpolate(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(1.0, start_stop, end_stop, tile.zoom))

#define prop_interpolate_exponential(base, start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(base, start_stop, end_stop, tile.zoom))

float prop_interpolate_factor(
  float base,
  float start_stop,
  float end_stop,
  float t
) {
  float difference = end_stop - start_stop;
  float progress = t - start_stop;

  if (difference == 0.0) return 0.0;
  else if (base == 1.0) return progress / difference;
  else return (pow(base, progress) - 1.0) / (pow(base, difference) - 1.0);
}


#pragma prop: declare(highp vec4 color)
#pragma prop: declare(highp float opacity)

out highp vec4 f_color;

void main() {
  #pragma prop: resolve
  f_color = color * opacity * tile.opacity;
}

''';

static const String background_vert = '''
#version 460 core

precision highp float;

uniform Tile {
  highp mat4 local_to_gl;
  highp float size;
  highp float extent;
  highp float opacity;
  highp float zoom;
} tile;

vec4 project_tile_position(vec2 position) {
  return vec4(position.x * tile.size, position.y * tile.size, 0.0, 1.0);
}

vec4 project_tile_position(vec3 position) {
  return vec4(position.x * tile.size, position.y * tile.size, position.z * tile.size, 1.0);
}

float project_pixel_length(float len) {
  return len * tile.size / tile.extent;
}

uniform FrameInfo {
  mat4 model_transform;
  mat4 camera_transform;
  vec3 camera_position;
} frame_info;

#define prop_crossfade(a, b) mix(a, b, tile.zoom - floor(tile.zoom))

#define prop_step(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, step(end_stop, tile.zoom))

#define prop_interpolate(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(1.0, start_stop, end_stop, tile.zoom))

#define prop_interpolate_exponential(base, start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(base, start_stop, end_stop, tile.zoom))

float prop_interpolate_factor(
  float base,
  float start_stop,
  float end_stop,
  float t
) {
  float difference = end_stop - start_stop;
  float progress = t - start_stop;

  if (difference == 0.0) return 0.0;
  else if (base == 1.0) return progress / difference;
  else return (pow(base, progress) - 1.0) / (pow(base, difference) - 1.0);
}


in highp vec2 position;

#pragma prop: declare(highp vec4 color)
#pragma prop: declare(highp float opacity)

void main() {
  #pragma prop: resolve(...)
  gl_Position = frame_info.camera_transform * frame_info.model_transform * project_tile_position(position);
}

''';

static const String fill_frag = '''
#version 460 core

precision highp float;

uniform Tile {
  highp mat4 local_to_gl;
  highp float size;
  highp float extent;
  highp float opacity;
  highp float zoom;
} tile;

vec4 project_tile_position(vec2 position) {
  return vec4(position.x * tile.size, position.y * tile.size, 0.0, 1.0);
}

vec4 project_tile_position(vec3 position) {
  return vec4(position.x * tile.size, position.y * tile.size, position.z * tile.size, 1.0);
}

float project_pixel_length(float len) {
  return len * tile.size / tile.extent;
}

#define prop_crossfade(a, b) mix(a, b, tile.zoom - floor(tile.zoom))

#define prop_step(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, step(end_stop, tile.zoom))

#define prop_interpolate(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(1.0, start_stop, end_stop, tile.zoom))

#define prop_interpolate_exponential(base, start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(base, start_stop, end_stop, tile.zoom))

float prop_interpolate_factor(
  float base,
  float start_stop,
  float end_stop,
  float t
) {
  float difference = end_stop - start_stop;
  float progress = t - start_stop;

  if (difference == 0.0) return 0.0;
  else if (base == 1.0) return progress / difference;
  else return (pow(base, progress) - 1.0) / (pow(base, difference) - 1.0);
}


#pragma prop: declare(bool antialias)
#pragma prop: declare(highp float opacity)
#pragma prop: declare(highp vec4 color)
#pragma prop: declare(highp vec2 translate)

out highp vec4 f_color;

void main() {
  #pragma prop: resolve(...)
  f_color = color * (opacity * tile.opacity);
}

''';

static const String fill_vert = '''
#version 460 core

precision highp float;

uniform Tile {
  highp mat4 local_to_gl;
  highp float size;
  highp float extent;
  highp float opacity;
  highp float zoom;
} tile;

vec4 project_tile_position(vec2 position) {
  return vec4(position.x * tile.size, position.y * tile.size, 0.0, 1.0);
}

vec4 project_tile_position(vec3 position) {
  return vec4(position.x * tile.size, position.y * tile.size, position.z * tile.size, 1.0);
}

float project_pixel_length(float len) {
  return len * tile.size / tile.extent;
}

uniform FrameInfo {
  mat4 model_transform;
  mat4 camera_transform;
  vec3 camera_position;
} frame_info;

#define prop_crossfade(a, b) mix(a, b, tile.zoom - floor(tile.zoom))

#define prop_step(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, step(end_stop, tile.zoom))

#define prop_interpolate(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(1.0, start_stop, end_stop, tile.zoom))

#define prop_interpolate_exponential(base, start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(base, start_stop, end_stop, tile.zoom))

float prop_interpolate_factor(
  float base,
  float start_stop,
  float end_stop,
  float t
) {
  float difference = end_stop - start_stop;
  float progress = t - start_stop;

  if (difference == 0.0) return 0.0;
  else if (base == 1.0) return progress / difference;
  else return (pow(base, progress) - 1.0) / (pow(base, difference) - 1.0);
}


in highp vec2 position;

#pragma prop: declare(bool antialias)
#pragma prop: declare(highp float opacity)
#pragma prop: declare(highp vec4 color)
#pragma prop: declare(highp vec2 translate)

void main() {
  #pragma prop: resolve
  gl_Position = frame_info.camera_transform * frame_info.model_transform * project_tile_position(position + translate);
}

''';

static const String fill_extrusion_frag = '''
#version 460 core

precision highp float;

#define prop_crossfade(a, b) mix(a, b, tile.zoom - floor(tile.zoom))

#define prop_step(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, step(end_stop, tile.zoom))

#define prop_interpolate(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(1.0, start_stop, end_stop, tile.zoom))

#define prop_interpolate_exponential(base, start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(base, start_stop, end_stop, tile.zoom))

float prop_interpolate_factor(
  float base,
  float start_stop,
  float end_stop,
  float t
) {
  float difference = end_stop - start_stop;
  float progress = t - start_stop;

  if (difference == 0.0) return 0.0;
  else if (base == 1.0) return progress / difference;
  else return (pow(base, progress) - 1.0) / (pow(base, difference) - 1.0);
}


#pragma prop: declare(highp float opacity)
#pragma prop: declare(highp vec4 color)
#pragma prop: declare(highp vec2 translate)
#pragma prop: declare(highp float height)
#pragma prop: declare(highp float base)

in float temp_height;
in vec3 v_normal;
out highp vec4 f_color;

void main() {
  #pragma prop: resolve(...)
  f_color = vec4(v_normal * 0.5 + 0.5, 1.0);
}

''';

static const String fill_extrusion_vert = '''
#version 460 core

precision highp float;

uniform Tile {
  highp mat4 local_to_gl;
  highp float size;
  highp float extent;
  highp float opacity;
  highp float zoom;
} tile;

vec4 project_tile_position(vec2 position) {
  return vec4(position.x * tile.size, position.y * tile.size, 0.0, 1.0);
}

vec4 project_tile_position(vec3 position) {
  return vec4(position.x * tile.size, position.y * tile.size, position.z * tile.size, 1.0);
}

float project_pixel_length(float len) {
  return len * tile.size / tile.extent;
}

uniform FrameInfo {
  mat4 model_transform;
  mat4 camera_transform;
  vec3 camera_position;
} frame_info;

#define prop_crossfade(a, b) mix(a, b, tile.zoom - floor(tile.zoom))

#define prop_step(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, step(end_stop, tile.zoom))

#define prop_interpolate(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(1.0, start_stop, end_stop, tile.zoom))

#define prop_interpolate_exponential(base, start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(base, start_stop, end_stop, tile.zoom))

float prop_interpolate_factor(
  float base,
  float start_stop,
  float end_stop,
  float t
) {
  float difference = end_stop - start_stop;
  float progress = t - start_stop;

  if (difference == 0.0) return 0.0;
  else if (base == 1.0) return progress / difference;
  else return (pow(base, progress) - 1.0) / (pow(base, difference) - 1.0);
}


in highp vec3 position;
in highp vec3 normal;

#pragma prop: declare(highp float opacity)
#pragma prop: declare(highp vec4 color)
#pragma prop: declare(highp vec2 translate)
#pragma prop: declare(highp float height)
#pragma prop: declare(highp float base)

out float temp_height;
out vec3 v_normal;

void main() {
  #pragma prop: resolve
  vec2 translatedPos = position.xy + translate;
  vec3 resolvedPos = vec3(translatedPos, base) + vec3(0.0, 0.0, position.z * height);

  temp_height = position.z;
  v_normal = normal;

  gl_Position = frame_info.camera_transform * frame_info.model_transform * project_tile_position(resolvedPos);
}

''';

static const String line_frag = '''
#version 460 core

#define prop_crossfade(a, b) mix(a, b, tile.zoom - floor(tile.zoom))

#define prop_step(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, step(end_stop, tile.zoom))

#define prop_interpolate(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(1.0, start_stop, end_stop, tile.zoom))

#define prop_interpolate_exponential(base, start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(base, start_stop, end_stop, tile.zoom))

float prop_interpolate_factor(
  float base,
  float start_stop,
  float end_stop,
  float t
) {
  float difference = end_stop - start_stop;
  float progress = t - start_stop;

  if (difference == 0.0) return 0.0;
  else if (base == 1.0) return progress / difference;
  else return (pow(base, progress) - 1.0) / (pow(base, difference) - 1.0);
}

uniform Tile {
  highp mat4 local_to_gl;
  highp float size;
  highp float extent;
  highp float opacity;
  highp float zoom;
} tile;

vec4 project_tile_position(vec2 position) {
  return vec4(position.x * tile.size, position.y * tile.size, 0.0, 1.0);
}

vec4 project_tile_position(vec3 position) {
  return vec4(position.x * tile.size, position.y * tile.size, position.z * tile.size, 1.0);
}

float project_pixel_length(float len) {
  return len * tile.size / tile.extent;
}


#pragma prop: declare(highp vec4 color)
#pragma prop: declare(float opacity)
#pragma prop: declare(float width)

out highp vec4 f_color;

void main() {
  #pragma prop: resolve(...)
  f_color = color * (opacity * tile.opacity);
}

''';

static const String line_vert = '''
#version 460 core

uniform Tile {
  highp mat4 local_to_gl;
  highp float size;
  highp float extent;
  highp float opacity;
  highp float zoom;
} tile;

vec4 project_tile_position(vec2 position) {
  return vec4(position.x * tile.size, position.y * tile.size, 0.0, 1.0);
}

vec4 project_tile_position(vec3 position) {
  return vec4(position.x * tile.size, position.y * tile.size, position.z * tile.size, 1.0);
}

float project_pixel_length(float len) {
  return len * tile.size / tile.extent;
}

uniform FrameInfo {
  mat4 model_transform;
  mat4 camera_transform;
  vec3 camera_position;
} frame_info;

#define prop_crossfade(a, b) mix(a, b, tile.zoom - floor(tile.zoom))

#define prop_step(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, step(end_stop, tile.zoom))

#define prop_interpolate(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(1.0, start_stop, end_stop, tile.zoom))

#define prop_interpolate_exponential(base, start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(base, start_stop, end_stop, tile.zoom))

float prop_interpolate_factor(
  float base,
  float start_stop,
  float end_stop,
  float t
) {
  float difference = end_stop - start_stop;
  float progress = t - start_stop;

  if (difference == 0.0) return 0.0;
  else if (base == 1.0) return progress / difference;
  else return (pow(base, progress) - 1.0) / (pow(base, difference) - 1.0);
}


in highp vec2 position;
in highp vec2 normal;

#pragma prop: declare(highp vec4 color)
#pragma prop: declare(float opacity)
#pragma prop: declare(float width)

void main() {
  #pragma prop: resolve

  // Width is defined in terms of screen pixels, so we need to convert it.
  float local_width = width * (tile.extent / tile.size);
  vec2 offset = normal * local_width * 0.5;
  gl_Position = frame_info.camera_transform * frame_info.model_transform * project_tile_position(position + offset);
}

''';

}