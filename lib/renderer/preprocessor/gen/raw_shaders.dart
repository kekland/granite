// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by tool/renderer/generate.js

// ignore_for_file: constant_identifier_names

// dart format off

class RawShaders {
static const String empty_material_frag = '''
#version 460 core

out vec4 f_color;

void main() {
  f_color = vec4(0.0);
}

''';

static const String texture_frag = '''
#version 460 core

uniform TextureUbo {
  float opacity;
} texture_ubo;

uniform sampler2D u_texture;

in vec2 v_texCoord;

out vec4 f_color;

void main() {
  vec4 color = texture(u_texture, v_texCoord) * texture_ubo.opacity;
  if (color.a < 0.01) discard;

  f_color = color;
}
''';

static const String texture_vert = '''
#version 460 core

in vec2 position;
in vec2 texCoord;

out vec2 v_texCoord;

void main() {
  gl_Position = vec4(position, 0.0, 1.0);
  v_texCoord = texCoord;
}
''';

static const String tile_stencil_vert = '''
#version 460 core

uniform TileStencilInfo {
  mat4 mvp;
} tile_stencil_info;

in highp vec2 position;

void main() {
  gl_Position = tile_stencil_info.mvp * vec4(position, 0.0, 1.0);
}

''';

static const String background_frag = '''
#version 460 core

precision highp float;

#define prop_crossfade(a, b) mix(a, b, tile_info.zoom - floor(tile_info.zoom))

#define prop_step(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, step(end_stop, tile_info.zoom))

#define prop_interpolate(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(1.0, start_stop, end_stop, tile_info.zoom))

#define prop_interpolate_exponential(base, start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(base, start_stop, end_stop, tile_info.zoom))

float prop_interpolate_factor(
  float base,
  float start_stop,
  float end_stop,
  float t
) {
  float difference = end_stop - start_stop;
  float progress = t - start_stop;

  if (difference == 0.0) return 0.0;
  else if (base == 1.0) return progress / difference;
  else return (pow(base, progress) - 1.0) / (pow(base, difference) - 1.0);
}

uniform sampler2D u_shadow_map;

float get_visibility(vec4 v_frag_pos_light_space, sampler2D u_shadow_map) {
  vec3 proj = v_frag_pos_light_space.xyz / v_frag_pos_light_space.w;
  if (proj.z <= 0.0 || proj.z >= 1.0) return 1.0;

  vec2 uv = proj.xy * 0.5 + 0.5;
  uv.y = 1.0 - uv.y;

  vec2 texel = 1.0 / vec2(2048);

  // biasing
  float slope = max(abs(dFdx(proj.z)), abs(dFdy(proj.z)));
  float min_bias = 0.00195;
  float slope_scale = 0.0005;
  float bias = max(min_bias, slope * slope_scale);

  // PCF
  float result = 0.0;
  const int K = 1;
  int taps = 0;

  for (int y = -K; y <= K; ++y)
  for (int x = -K; x <= K; ++x) {
      vec2 offset = vec2(x, y) * texel;
      float closest = texture(u_shadow_map, uv + offset).r;
      float lit = (proj.z - bias > closest) ? 0.0 : 1.0;
      result += lit;
      taps++;
  }

  return result / float(taps);
}

#pragma prop: declare(highp vec4 color)
#pragma prop: declare(highp float opacity)

in vec4 v_frag_pos_light_space;

out highp vec4 f_color;

void main() {
  #pragma prop: resolve
  float visibility = get_visibility(v_frag_pos_light_space, u_shadow_map);
  visibility = visibility * 0.5 + 0.5;
  f_color = vec4(color.rgb * visibility, color.a) * opacity;
}

''';

static const String background_vert = '''
#version 460 core

precision highp float;

layout (std140) uniform TileInfo {
  // transforms and camera
  mat4 mvp;
  mat4 camera_transform;
  mat4 model_transform;
  vec3 camera_position;

  // light
  vec3 light_direction;
  float light_intensity;
  vec4 light_color;
  mat4 light_mvp;

  // other data
  float units_per_pixel;
  float zoom;
} tile_info;

#define prop_crossfade(a, b) mix(a, b, tile_info.zoom - floor(tile_info.zoom))

#define prop_step(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, step(end_stop, tile_info.zoom))

#define prop_interpolate(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(1.0, start_stop, end_stop, tile_info.zoom))

#define prop_interpolate_exponential(base, start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(base, start_stop, end_stop, tile_info.zoom))

float prop_interpolate_factor(
  float base,
  float start_stop,
  float end_stop,
  float t
) {
  float difference = end_stop - start_stop;
  float progress = t - start_stop;

  if (difference == 0.0) return 0.0;
  else if (base == 1.0) return progress / difference;
  else return (pow(base, progress) - 1.0) / (pow(base, difference) - 1.0);
}


in highp vec2 position;

#pragma prop: declare(highp vec4 color)
#pragma prop: declare(highp float opacity)

out vec4 v_frag_pos_light_space;

void main() {
  #pragma prop: resolve

  v_frag_pos_light_space = tile_info.light_mvp * vec4(position, 0.0, 1.0);
  gl_Position = tile_info.mvp * vec4(position, 0.0, 1.0);
}

''';

static const String fill_frag = '''
#version 460 core

precision highp float;

#define prop_crossfade(a, b) mix(a, b, tile_info.zoom - floor(tile_info.zoom))

#define prop_step(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, step(end_stop, tile_info.zoom))

#define prop_interpolate(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(1.0, start_stop, end_stop, tile_info.zoom))

#define prop_interpolate_exponential(base, start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(base, start_stop, end_stop, tile_info.zoom))

float prop_interpolate_factor(
  float base,
  float start_stop,
  float end_stop,
  float t
) {
  float difference = end_stop - start_stop;
  float progress = t - start_stop;

  if (difference == 0.0) return 0.0;
  else if (base == 1.0) return progress / difference;
  else return (pow(base, progress) - 1.0) / (pow(base, difference) - 1.0);
}

uniform sampler2D u_shadow_map;

float get_visibility(vec4 v_frag_pos_light_space, sampler2D u_shadow_map) {
  vec3 proj = v_frag_pos_light_space.xyz / v_frag_pos_light_space.w;
  if (proj.z <= 0.0 || proj.z >= 1.0) return 1.0;

  vec2 uv = proj.xy * 0.5 + 0.5;
  uv.y = 1.0 - uv.y;

  vec2 texel = 1.0 / vec2(2048);

  // biasing
  float slope = max(abs(dFdx(proj.z)), abs(dFdy(proj.z)));
  float min_bias = 0.00195;
  float slope_scale = 0.0005;
  float bias = max(min_bias, slope * slope_scale);

  // PCF
  float result = 0.0;
  const int K = 1;
  int taps = 0;

  for (int y = -K; y <= K; ++y)
  for (int x = -K; x <= K; ++x) {
      vec2 offset = vec2(x, y) * texel;
      float closest = texture(u_shadow_map, uv + offset).r;
      float lit = (proj.z - bias > closest) ? 0.0 : 1.0;
      result += lit;
      taps++;
  }

  return result / float(taps);
}

#pragma prop: declare(bool antialias)
#pragma prop: declare(highp float opacity)
#pragma prop: declare(highp vec4 color)
#pragma prop: declare(highp vec2 translate)

in vec4 v_frag_pos_light_space;

out highp vec4 f_color;

void main() {
  #pragma prop: resolve
  float visibility = get_visibility(v_frag_pos_light_space, u_shadow_map);
  visibility = visibility * 0.5 + 0.5;
  f_color = vec4(color.rgb * visibility, color.a) * opacity;
}

''';

static const String fill_vert = '''
#version 460 core

precision highp float;

layout (std140) uniform TileInfo {
  // transforms and camera
  mat4 mvp;
  mat4 camera_transform;
  mat4 model_transform;
  vec3 camera_position;

  // light
  vec3 light_direction;
  float light_intensity;
  vec4 light_color;
  mat4 light_mvp;

  // other data
  float units_per_pixel;
  float zoom;
} tile_info;

#define prop_crossfade(a, b) mix(a, b, tile_info.zoom - floor(tile_info.zoom))

#define prop_step(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, step(end_stop, tile_info.zoom))

#define prop_interpolate(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(1.0, start_stop, end_stop, tile_info.zoom))

#define prop_interpolate_exponential(base, start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(base, start_stop, end_stop, tile_info.zoom))

float prop_interpolate_factor(
  float base,
  float start_stop,
  float end_stop,
  float t
) {
  float difference = end_stop - start_stop;
  float progress = t - start_stop;

  if (difference == 0.0) return 0.0;
  else if (base == 1.0) return progress / difference;
  else return (pow(base, progress) - 1.0) / (pow(base, difference) - 1.0);
}


in highp vec2 position;

#pragma prop: declare(bool antialias)
#pragma prop: declare(highp float opacity)
#pragma prop: declare(highp vec4 color)
#pragma prop: declare(highp vec2 translate)

out vec4 v_frag_pos_light_space;

void main() {
  #pragma prop: resolve
  vec2 translated = position + translate;

  v_frag_pos_light_space = tile_info.light_mvp * vec4(translated, 0.0, 1.0);
  gl_Position = tile_info.mvp * vec4(translated, 0.0, 1.0);
}

''';

static const String fill_extrusion_frag = '''
#version 460 core

precision highp float;

#define prop_crossfade(a, b) mix(a, b, tile_info.zoom - floor(tile_info.zoom))

#define prop_step(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, step(end_stop, tile_info.zoom))

#define prop_interpolate(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(1.0, start_stop, end_stop, tile_info.zoom))

#define prop_interpolate_exponential(base, start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(base, start_stop, end_stop, tile_info.zoom))

float prop_interpolate_factor(
  float base,
  float start_stop,
  float end_stop,
  float t
) {
  float difference = end_stop - start_stop;
  float progress = t - start_stop;

  if (difference == 0.0) return 0.0;
  else if (base == 1.0) return progress / difference;
  else return (pow(base, progress) - 1.0) / (pow(base, difference) - 1.0);
}

layout (std140) uniform TileInfo {
  // transforms and camera
  mat4 mvp;
  mat4 camera_transform;
  mat4 model_transform;
  vec3 camera_position;

  // light
  vec3 light_direction;
  float light_intensity;
  vec4 light_color;
  mat4 light_mvp;

  // other data
  float units_per_pixel;
  float zoom;
} tile_info;

uniform sampler2D u_shadow_map;

float get_visibility(vec4 v_frag_pos_light_space, sampler2D u_shadow_map) {
  vec3 proj = v_frag_pos_light_space.xyz / v_frag_pos_light_space.w;
  if (proj.z <= 0.0 || proj.z >= 1.0) return 1.0;

  vec2 uv = proj.xy * 0.5 + 0.5;
  uv.y = 1.0 - uv.y;

  vec2 texel = 1.0 / vec2(2048);

  // biasing
  float slope = max(abs(dFdx(proj.z)), abs(dFdy(proj.z)));
  float min_bias = 0.00195;
  float slope_scale = 0.0005;
  float bias = max(min_bias, slope * slope_scale);

  // PCF
  float result = 0.0;
  const int K = 1;
  int taps = 0;

  for (int y = -K; y <= K; ++y)
  for (int x = -K; x <= K; ++x) {
      vec2 offset = vec2(x, y) * texel;
      float closest = texture(u_shadow_map, uv + offset).r;
      float lit = (proj.z - bias > closest) ? 0.0 : 1.0;
      result += lit;
      taps++;
  }

  return result / float(taps);
}

#pragma prop: declare(highp vec4 color)
#pragma prop: declare(highp vec2 translate)
#pragma prop: declare(highp float height)
#pragma prop: declare(highp float base)

in vec3 v_position;
in vec3 v_normal;
in vec4 v_frag_pos_light_space;

out highp vec4 f_color;

void main() {
  #pragma prop: resolve(...)

  // Shadow mapping
  float visibility = get_visibility(v_frag_pos_light_space, u_shadow_map);

  // Lights
  vec3 light_color = tile_info.light_color.rgb;
  float light_intensity = tile_info.light_intensity;

  // Ambient occlussion based on the distance from ground
  float ao_intensity = clamp((24.0 - v_position.z) / 24.0, 0.0, 1.0) * 0.125;

  // No AO on the floors/roofs
  ao_intensity *= 1.0 - abs(v_normal.z);
  vec3 ao = vec3(ao_intensity);

  float diffuse_amount = max(dot(v_normal, tile_info.light_direction), 0.0);
  vec3 ambient = light_color * light_intensity * 1.0;
  vec3 diffuse = light_color * light_intensity * diffuse_amount * visibility;
  vec4 light = vec4(ambient + diffuse - ao, 1.0);

  vec4 result_color = color * light;
  f_color = result_color;
}

''';

static const String fill_extrusion_vert = '''
#version 460 core

precision highp float;

layout (std140) uniform TileInfo {
  // transforms and camera
  mat4 mvp;
  mat4 camera_transform;
  mat4 model_transform;
  vec3 camera_position;

  // light
  vec3 light_direction;
  float light_intensity;
  vec4 light_color;
  mat4 light_mvp;

  // other data
  float units_per_pixel;
  float zoom;
} tile_info;

#define prop_crossfade(a, b) mix(a, b, tile_info.zoom - floor(tile_info.zoom))

#define prop_step(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, step(end_stop, tile_info.zoom))

#define prop_interpolate(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(1.0, start_stop, end_stop, tile_info.zoom))

#define prop_interpolate_exponential(base, start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(base, start_stop, end_stop, tile_info.zoom))

float prop_interpolate_factor(
  float base,
  float start_stop,
  float end_stop,
  float t
) {
  float difference = end_stop - start_stop;
  float progress = t - start_stop;

  if (difference == 0.0) return 0.0;
  else if (base == 1.0) return progress / difference;
  else return (pow(base, progress) - 1.0) / (pow(base, difference) - 1.0);
}


in highp vec3 position;
in highp vec3 normal;

#pragma prop: declare(highp vec4 color)
#pragma prop: declare(highp vec2 translate)
#pragma prop: declare(highp float height)
#pragma prop: declare(highp float base)

out vec3 v_position;
out vec3 v_normal;
out vec4 v_frag_pos_light_space;

void main() {
  #pragma prop: resolve
  vec2 translated_pos = position.xy + translate;
  vec3 resolved_pos = vec3(translated_pos.xy, base) + vec3(0.0, 0.0, position.z * height);

  v_position = resolved_pos;
  v_normal = normal;
  v_frag_pos_light_space = tile_info.light_mvp * vec4(resolved_pos + v_normal * 0.02, 1.0);
  gl_Position = tile_info.mvp * vec4(resolved_pos, 1.0);
}

''';

static const String line_frag = '''
#version 460 core

#define prop_crossfade(a, b) mix(a, b, tile_info.zoom - floor(tile_info.zoom))

#define prop_step(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, step(end_stop, tile_info.zoom))

#define prop_interpolate(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(1.0, start_stop, end_stop, tile_info.zoom))

#define prop_interpolate_exponential(base, start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(base, start_stop, end_stop, tile_info.zoom))

float prop_interpolate_factor(
  float base,
  float start_stop,
  float end_stop,
  float t
) {
  float difference = end_stop - start_stop;
  float progress = t - start_stop;

  if (difference == 0.0) return 0.0;
  else if (base == 1.0) return progress / difference;
  else return (pow(base, progress) - 1.0) / (pow(base, difference) - 1.0);
}

uniform sampler2D u_shadow_map;

float get_visibility(vec4 v_frag_pos_light_space, sampler2D u_shadow_map) {
  vec3 proj = v_frag_pos_light_space.xyz / v_frag_pos_light_space.w;
  if (proj.z <= 0.0 || proj.z >= 1.0) return 1.0;

  vec2 uv = proj.xy * 0.5 + 0.5;
  uv.y = 1.0 - uv.y;

  vec2 texel = 1.0 / vec2(2048);

  // biasing
  float slope = max(abs(dFdx(proj.z)), abs(dFdy(proj.z)));
  float min_bias = 0.00195;
  float slope_scale = 0.0005;
  float bias = max(min_bias, slope * slope_scale);

  // PCF
  float result = 0.0;
  const int K = 1;
  int taps = 0;

  for (int y = -K; y <= K; ++y)
  for (int x = -K; x <= K; ++x) {
      vec2 offset = vec2(x, y) * texel;
      float closest = texture(u_shadow_map, uv + offset).r;
      float lit = (proj.z - bias > closest) ? 0.0 : 1.0;
      result += lit;
      taps++;
  }

  return result / float(taps);
}

#pragma prop: declare(highp vec4 color)
#pragma prop: declare(float opacity)
#pragma prop: declare(float width)

in vec4 v_frag_pos_light_space;

out highp vec4 f_color;

void main() {
  #pragma prop: resolve
  float visibility = get_visibility(v_frag_pos_light_space, u_shadow_map);
  visibility = visibility * 0.5 + 0.5;
  f_color = vec4(color.rgb * visibility, color.a) * opacity;
}

''';

static const String line_vert = '''
#version 460 core

layout (std140) uniform TileInfo {
  // transforms and camera
  mat4 mvp;
  mat4 camera_transform;
  mat4 model_transform;
  vec3 camera_position;

  // light
  vec3 light_direction;
  float light_intensity;
  vec4 light_color;
  mat4 light_mvp;

  // other data
  float units_per_pixel;
  float zoom;
} tile_info;

#define prop_crossfade(a, b) mix(a, b, tile_info.zoom - floor(tile_info.zoom))

#define prop_step(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, step(end_stop, tile_info.zoom))

#define prop_interpolate(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(1.0, start_stop, end_stop, tile_info.zoom))

#define prop_interpolate_exponential(base, start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(base, start_stop, end_stop, tile_info.zoom))

float prop_interpolate_factor(
  float base,
  float start_stop,
  float end_stop,
  float t
) {
  float difference = end_stop - start_stop;
  float progress = t - start_stop;

  if (difference == 0.0) return 0.0;
  else if (base == 1.0) return progress / difference;
  else return (pow(base, progress) - 1.0) / (pow(base, difference) - 1.0);
}


in highp vec2 position;
in highp vec2 normal;

#pragma prop: declare(highp vec4 color)
#pragma prop: declare(float opacity)
#pragma prop: declare(float width)

out vec4 v_frag_pos_light_space;

void main() {
  #pragma prop: resolve

  // Width is defined in terms of screen pixels, so we need to convert it.
  float local_width = width * tile_info.units_per_pixel;
  vec2 offset = normal * local_width * 0.5;
  vec2 resolved_pos = position + offset;

  v_frag_pos_light_space = tile_info.light_mvp * vec4(resolved_pos, 0.0, 1.0);
  gl_Position = tile_info.mvp * vec4(resolved_pos, 0.0, 1.0);
}

''';

static const String line_dashed_frag = '''
#version 460 core

#define prop_crossfade(a, b) mix(a, b, tile_info.zoom - floor(tile_info.zoom))

#define prop_step(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, step(end_stop, tile_info.zoom))

#define prop_interpolate(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(1.0, start_stop, end_stop, tile_info.zoom))

#define prop_interpolate_exponential(base, start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(base, start_stop, end_stop, tile_info.zoom))

float prop_interpolate_factor(
  float base,
  float start_stop,
  float end_stop,
  float t
) {
  float difference = end_stop - start_stop;
  float progress = t - start_stop;

  if (difference == 0.0) return 0.0;
  else if (base == 1.0) return progress / difference;
  else return (pow(base, progress) - 1.0) / (pow(base, difference) - 1.0);
}

uniform sampler2D u_shadow_map;

float get_visibility(vec4 v_frag_pos_light_space, sampler2D u_shadow_map) {
  vec3 proj = v_frag_pos_light_space.xyz / v_frag_pos_light_space.w;
  if (proj.z <= 0.0 || proj.z >= 1.0) return 1.0;

  vec2 uv = proj.xy * 0.5 + 0.5;
  uv.y = 1.0 - uv.y;

  vec2 texel = 1.0 / vec2(2048);

  // biasing
  float slope = max(abs(dFdx(proj.z)), abs(dFdy(proj.z)));
  float min_bias = 0.00195;
  float slope_scale = 0.0005;
  float bias = max(min_bias, slope * slope_scale);

  // PCF
  float result = 0.0;
  const int K = 1;
  int taps = 0;

  for (int y = -K; y <= K; ++y)
  for (int x = -K; x <= K; ++x) {
      vec2 offset = vec2(x, y) * texel;
      float closest = texture(u_shadow_map, uv + offset).r;
      float lit = (proj.z - bias > closest) ? 0.0 : 1.0;
      result += lit;
      taps++;
  }

  return result / float(taps);
}

uniform DasharrayInfo {
  highp vec2 texture_size;
} dasharray_info;

uniform sampler2D u_dasharray;

#pragma prop: declare(highp vec4 color)
#pragma prop: declare(float opacity)
#pragma prop: declare(float width)

in float v_line_length;
in vec4 v_frag_pos_light_space;

out highp vec4 f_color;

void main() {
  #pragma prop: resolve

  // Shadows
  float visibility = get_visibility(v_frag_pos_light_space, u_shadow_map);
  visibility = visibility * 0.5 + 0.5;

  // Dash pattern
  float line_position = v_line_length / width;
  float dash_value = texture(u_dasharray, vec2(line_position / dasharray_info.texture_size.x, 0.5)).r;
  if (dash_value < 0.5) discard;

  f_color = vec4(color.rgb * visibility, color.a) * opacity;
}

''';

static const String line_dashed_vert = '''
#version 460 core

layout (std140) uniform TileInfo {
  // transforms and camera
  mat4 mvp;
  mat4 camera_transform;
  mat4 model_transform;
  vec3 camera_position;

  // light
  vec3 light_direction;
  float light_intensity;
  vec4 light_color;
  mat4 light_mvp;

  // other data
  float units_per_pixel;
  float zoom;
} tile_info;

#define prop_crossfade(a, b) mix(a, b, tile_info.zoom - floor(tile_info.zoom))

#define prop_step(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, step(end_stop, tile_info.zoom))

#define prop_interpolate(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(1.0, start_stop, end_stop, tile_info.zoom))

#define prop_interpolate_exponential(base, start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, prop_interpolate_factor(base, start_stop, end_stop, tile_info.zoom))

float prop_interpolate_factor(
  float base,
  float start_stop,
  float end_stop,
  float t
) {
  float difference = end_stop - start_stop;
  float progress = t - start_stop;

  if (difference == 0.0) return 0.0;
  else if (base == 1.0) return progress / difference;
  else return (pow(base, progress) - 1.0) / (pow(base, difference) - 1.0);
}


in highp vec2 position;
in highp vec2 normal;
in highp float line_length;

#pragma prop: declare(highp vec4 color)
#pragma prop: declare(float opacity)
#pragma prop: declare(float width)

out float v_line_length;
out vec4 v_frag_pos_light_space;

void main() {
  #pragma prop: resolve

  // Width is defined in terms of screen pixels, so we need to convert it.
  float local_width = width * tile_info.units_per_pixel;
  vec2 offset = normal * local_width * 0.5;
  vec2 resolved_pos = position + offset;

  v_frag_pos_light_space = tile_info.light_mvp * vec4(resolved_pos, 0.0, 1.0);
  gl_Position = tile_info.mvp * vec4(resolved_pos, 0.0, 1.0);
  v_line_length = line_length / tile_info.units_per_pixel;
}

''';

}